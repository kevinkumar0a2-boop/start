name: RDP

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600

    steps:
      - name: Configure Core RDP Settings
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          netsh advfirewall firewall delete rule name="RDP-Local"
          netsh advfirewall firewall add rule name="RDP-Local" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force

      - name: Create RDP User with Custom Credentials
        run: |
          $username = "${{ secrets.RDP_USERNAME }}"
          $password = "${{ secrets.RDP_PASSWORD }}"
          
          if ([string]::IsNullOrWhiteSpace($username) -or [string]::IsNullOrWhiteSpace($password)) {
              Write-Error "RDP_USERNAME and RDP_PASSWORD secrets must be set in repository settings"
              exit 1
          }
          
          secedit /export /cfg "$env:TEMP\secpol.cfg" | Out-Null
          (Get-Content "$env:TEMP\secpol.cfg") -replace "PasswordComplexity = 1", "PasswordComplexity = 0" | Set-Content "$env:TEMP\secpol_new.cfg"
          secedit /configure /db c:\windows\security\local.sdb /cfg "$env:TEMP\secpol_new.cfg" /areas SECURITYPOLICY | Out-Null
          Remove-Item "$env:TEMP\secpol.cfg", "$env:TEMP\secpol_new.cfg" -Force -ErrorAction SilentlyContinue
          
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          try {
              New-LocalUser -Name $username -Password $securePass -AccountNeverExpires -ErrorAction Stop
              Write-Host "User '$username' created successfully"
          } catch {
              Write-Error "Failed to create user. Error: $($_.Exception.Message)"
              exit 1
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $username
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username
          
          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV
          
          if (-not (Get-LocalUser -Name $username)) {
              Write-Error "User creation verification failed"
              exit 1
          }
          
          Write-Host "RDP user '$username' configured and ready"

      - name: Download and Install Pinggy Client
        run: |
          $pinggyUrl = "https://s3.ap-south-1.amazonaws.com/public.pinggy.binaries/cli/v0.2.5/windows/amd64/pinggy.exe"
          $pinggyPath = "$env:TEMP\pinggy.exe"
          
          Write-Host "Downloading Pinggy client from $pinggyUrl"
          Invoke-WebRequest -Uri $pinggyUrl -OutFile $pinggyPath -UseBasicParsing
          
          if (-not (Test-Path $pinggyPath)) {
              Write-Error "Failed to download pinggy.exe"
              exit 1
          }
          
          Write-Host "Pinggy client downloaded successfully to $pinggyPath"
          echo "PINGGY_PATH=$pinggyPath" >> $env:GITHUB_ENV
      
      - name: Verify RDP Service
        run: |
          $testResult = Test-NetConnection -ComputerName 127.0.0.1 -Port 3389
          if (-not $testResult.TcpTestSucceeded) {
              Write-Error "RDP service not responding on localhost:3389"
              exit 1
          }
          Write-Host "RDP service verified and ready"

      - name: Run Tunnel Manager with Auto-Refresh
        run: |
          $pinggyExe = $env:PINGGY_PATH
          
          function Start-PinggyTunnel {
              $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              Write-Host "[$timestamp] Starting Pinggy tunnel..."
              
              # Kill any existing pinggy processes
              Get-Process pinggy -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 3
              
              # Verify pinggy.exe exists
              if (-not (Test-Path $pinggyExe)) {
                  Write-Error "Pinggy executable not found at $pinggyExe"
                  exit 1
              }
              
              Write-Host "Starting Pinggy tunnel process..."
              
              # Start Pinggy with connection string
              $pinggyArgs = @(
                  "-p", "443",
                  "-R0:127.0.0.1:3389",
                  "-o", "StrictHostKeyChecking=no",
                  "-o", "ServerAliveInterval=30",
                  "m9oKScbEcJh+tcp@free.pinggy.io"
              )
              
              $processInfo = New-Object System.Diagnostics.ProcessStartInfo
              $processInfo.FileName = $pinggyExe
              $processInfo.Arguments = $pinggyArgs -join " "
              $processInfo.RedirectStandardOutput = $true
              $processInfo.RedirectStandardError = $true
              $processInfo.UseShellExecute = $false
              $processInfo.CreateNoWindow = $true
              
              $process = New-Object System.Diagnostics.Process
              $process.StartInfo = $processInfo
              
              # Capture output in real-time
              $stdoutBuilder = New-Object System.Text.StringBuilder
              $stderrBuilder = New-Object System.Text.StringBuilder
              
              $stdoutEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action {
                  if ($EventArgs.Data) {
                      [void]$Event.MessageData.AppendLine($EventArgs.Data)
                      Write-Host "[PINGGY] $($EventArgs.Data)"
                  }
              } -MessageData $stdoutBuilder
              
              $stderrEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action {
                  if ($EventArgs.Data) {
                      [void]$Event.MessageData.AppendLine($EventArgs.Data)
                      Write-Host "[PINGGY-ERR] $($EventArgs.Data)"
                  }
              } -MessageData $stderrBuilder
              
              $started = $process.Start()
              if (-not $started) {
                  Write-Error "Failed to start Pinggy process"
                  exit 1
              }
              
              $process.BeginOutputReadLine()
              $process.BeginErrorReadLine()
              
              Write-Host "Pinggy process started with PID: $($process.Id)"
              Write-Host "Waiting for tunnel URL (this takes 10-20 seconds)..."
              
              # Wait and extract URL
              $pinggyUrl = "URL not captured yet"
              $maxWait = 60
              $elapsed = 0
              
              while ($elapsed -lt $maxWait) {
                  Start-Sleep -Seconds 2
                  $elapsed += 2
                  
                  # Check if process died
                  if ($process.HasExited) {
                      Write-Host "Pinggy process exited with code: $($process.ExitCode)"
                      $stdout = $stdoutBuilder.ToString()
                      $stderr = $stderrBuilder.ToString()
                      Write-Host "`nFinal STDOUT:`n$stdout"
                      Write-Host "`nFinal STDERR:`n$stderr"
                      Write-Error "Pinggy tunnel failed to establish"
                      exit 1
                  }
                  
                  # Try to extract URL from captured output
                  $combinedOutput = $stdoutBuilder.ToString() + $stderrBuilder.ToString()
                  
                  # Match various Pinggy URL formats
                  if ($combinedOutput -match "(?:tcp://|https://|http://)([^\s\n\r\)\]]+)") {
                      $pinggyUrl = $matches[0].Trim()
                      Write-Host "`nURL FOUND: $pinggyUrl" -ForegroundColor Green
                      break
                  }
                  
                  if ($elapsed % 10 -eq 0) {
                      Write-Host "Waiting... ($elapsed/$maxWait seconds)"
                  }
              }
              
              # Cleanup event handlers
              Unregister-Event -SourceIdentifier $stdoutEvent.Name -ErrorAction SilentlyContinue
              Unregister-Event -SourceIdentifier $stderrEvent.Name -ErrorAction SilentlyContinue
              
              Write-Host "`n========================================" -ForegroundColor Cyan
              Write-Host "=== TUNNEL ESTABLISHED ===" -ForegroundColor Cyan
              Write-Host "========================================" -ForegroundColor Cyan
              Write-Host "URL: $pinggyUrl" -ForegroundColor Green
              Write-Host "PID: $($process.Id)" -ForegroundColor Yellow
              Write-Host "========================================`n" -ForegroundColor Cyan
              
              return @{
                  Process = $process
                  URL = $pinggyUrl
              }
          }
          
          while ($true) {
              $tunnelInfo = Start-PinggyTunnel
              $process = $tunnelInfo.Process
              $url = $tunnelInfo.URL
              
              Write-Host "`n========================================"
              Write-Host "=== RDP ACCESS VIA PINGGY TUNNEL ==="
              Write-Host "========================================"
              Write-Host "Connection URL: $url"
              Write-Host "Username: $env:RDP_USERNAME"
              Write-Host "Password: $env:RDP_PASSWORD"
              Write-Host ""
              Write-Host "Connect using your RDP client:"
              Write-Host "  - Use the URL above as host:port"
              Write-Host "  - Tunnel will refresh in 55 minutes"
              Write-Host "========================================"
              Write-Host ""
              
              $endTime = (Get-Date).AddMinutes(55)
              while ((Get-Date) -lt $endTime) {
                  $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                  $remaining = [math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)
                  
                  if ($process.HasExited) {
                      Write-Host "[$timestamp] WARNING: Tunnel died unexpectedly! Restarting..." -ForegroundColor Red
                      break
                  }
                  
                  Write-Host "[$timestamp] Tunnel active - $remaining minutes until refresh"
                  Start-Sleep -Seconds 300
              }
              
              Write-Host "`nRefreshing tunnel with new URL..." -ForegroundColor Yellow
              if (-not $process.HasExited) {
                  $process.Kill()
              }
              $process.Dispose()
              Start-Sleep -Seconds 3
          }

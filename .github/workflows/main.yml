name: RDP

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600

    steps:
      - name: Configure Core RDP Settings
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          netsh advfirewall firewall delete rule name="RDP-Local"
          netsh advfirewall firewall add rule name="RDP-Local" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force

      - name: Create RDP User with Custom Credentials
        run: |
          $username = "${{ secrets.RDP_USERNAME }}"
          $password = "${{ secrets.RDP_PASSWORD }}"
          
          if ([string]::IsNullOrWhiteSpace($username) -or [string]::IsNullOrWhiteSpace($password)) {
              Write-Error "RDP_USERNAME and RDP_PASSWORD secrets must be set in repository settings"
              exit 1
          }
          
          secedit /export /cfg "$env:TEMP\secpol.cfg" | Out-Null
          (Get-Content "$env:TEMP\secpol.cfg") -replace "PasswordComplexity = 1", "PasswordComplexity = 0" | Set-Content "$env:TEMP\secpol_new.cfg"
          secedit /configure /db c:\windows\security\local.sdb /cfg "$env:TEMP\secpol_new.cfg" /areas SECURITYPOLICY | Out-Null
          Remove-Item "$env:TEMP\secpol.cfg", "$env:TEMP\secpol_new.cfg" -Force -ErrorAction SilentlyContinue
          
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          try {
              New-LocalUser -Name $username -Password $securePass -AccountNeverExpires -ErrorAction Stop
              Write-Host "User '$username' created successfully"
          } catch {
              Write-Error "Failed to create user. Error: $($_.Exception.Message)"
              exit 1
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $username
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username
          
          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV
          
          if (-not (Get-LocalUser -Name $username)) {
              Write-Error "User creation verification failed"
              exit 1
          }
          
          Write-Host "RDP user '$username' configured and ready"

      - name: Install and Configure OpenSSH Client
        run: |
          $sshClient = Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH.Client*'
          if ($sshClient.State -ne "Installed") {
              Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
          }
          Write-Host "OpenSSH client ready"
      
      - name: Verify RDP Service
        run: |
          $testResult = Test-NetConnection -ComputerName 127.0.0.1 -Port 3389
          if (-not $testResult.TcpTestSucceeded) {
              Write-Error "RDP service not responding on localhost:3389"
              exit 1
          }
          Write-Host "RDP service verified and ready"

      - name: Run Tunnel Manager with Auto-Refresh
        run: |
          function Start-PinggyTunnel {
              $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              Write-Host "[$timestamp] Starting Pinggy tunnel..."
              
              Get-Process ssh -ErrorAction SilentlyContinue | Where-Object {
                  $_.CommandLine -like "*pinggy.io*"
              } | Stop-Process -Force -ErrorAction SilentlyContinue
              
              Start-Sleep -Seconds 2
              
              $logFile = "$env:TEMP\pinggy_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
              $errorFile = "$env:TEMP\pinggy_error_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
              $process = Start-Process -FilePath "ssh" -ArgumentList "-p", "443", "-R0:127.0.0.1:3389", "-o", "StrictHostKeyChecking=no", "-o", "ServerAliveInterval=30", "-o", "ExitOnForwardFailure=yes", "m9oKScbEcJh+tcp@free.pinggy.io" -NoNewWindow -PassThru -RedirectStandardOutput $logFile -RedirectStandardError $errorFile
              
              Write-Host "Waiting for Pinggy URL (checking both stdout and stderr)..."
              Start-Sleep -Seconds 20
              
              $pinggyUrl = "URL not found"
              $attempts = 0
              while ($attempts -lt 30) {
                  $foundUrl = $false
                  
                  if (Test-Path $logFile) {
                      $output = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
                      if ($output -and $output.Trim()) {
                          Write-Host "STDOUT Content: $output"
                          if ($output -match "tcp://([^\s\n\r]+)") {
                              $pinggyUrl = $matches[1].Trim()
                              $foundUrl = $true
                          }
                      }
                  }
                  
                  if (-not $foundUrl -and (Test-Path $errorFile)) {
                      $errorOutput = Get-Content $errorFile -Raw -ErrorAction SilentlyContinue
                      if ($errorOutput -and $errorOutput.Trim()) {
                          Write-Host "STDERR Content: $errorOutput"
                          if ($errorOutput -match "tcp://([^\s\n\r]+)") {
                              $pinggyUrl = $matches[1].Trim()
                              $foundUrl = $true
                          }
                      }
                  }
                  
                  if ($foundUrl) {
                      break
                  }
                  
                  Start-Sleep -Seconds 3
                  $attempts++
                  Write-Host "Attempt $attempts/30 - Still waiting for URL..."
              }
              
              Write-Host "`n========================================" -ForegroundColor Cyan
              Write-Host "=== NEW TUNNEL ESTABLISHED ===" -ForegroundColor Cyan
              Write-Host "========================================" -ForegroundColor Cyan
              Write-Host "URL: $pinggyUrl" -ForegroundColor Green
              Write-Host "PID: $($process.Id)" -ForegroundColor Yellow
              Write-Host "========================================`n" -ForegroundColor Cyan
              
              Write-Host "Full Output from STDOUT:"
              if (Test-Path $logFile) {
                  Get-Content $logFile | Write-Host
              } else {
                  Write-Host "(No stdout output)"
              }
              
              Write-Host "`nFull Output from STDERR:"
              if (Test-Path $errorFile) {
                  Get-Content $errorFile | Write-Host
              } else {
                  Write-Host "(No stderr output)"
              }
              Write-Host ""
              
              return @{
                  Process = $process
                  URL = $pinggyUrl
                  LogFile = $logFile
                  ErrorFile = $errorFile
              }
          }
          
          while ($true) {
              $tunnelInfo = Start-PinggyTunnel
              $process = $tunnelInfo.Process
              $url = $tunnelInfo.URL
              
              Write-Host "`n========================================"
              Write-Host "=== RDP ACCESS VIA PINGGY TUNNEL ==="
              Write-Host "========================================"
              Write-Host "Connection URL: $url"
              Write-Host "Username: $env:RDP_USERNAME"
              Write-Host "Password: $env:RDP_PASSWORD"
              Write-Host ""
              Write-Host "Connect using your RDP client:"
              Write-Host "  - Use the URL above as host:port"
              Write-Host "  - Tunnel will refresh in 55 minutes"
              Write-Host "========================================"
              Write-Host ""
              
              $endTime = (Get-Date).AddMinutes(55)
              while ((Get-Date) -lt $endTime) {
                  $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                  $remaining = [math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)
                  
                  if (-not (Get-Process -Id $process.Id -ErrorAction SilentlyContinue)) {
                      Write-Host "[$timestamp] WARNING: Tunnel died unexpectedly! Restarting..." -ForegroundColor Red
                      break
                  }
                  
                  Write-Host "[$timestamp] Tunnel active - $remaining minutes until refresh"
                  Start-Sleep -Seconds 300
              }
              
              Write-Host "`nRefreshing tunnel with new URL..." -ForegroundColor Yellow
              Stop-Process -Id $process.Id -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 3
          }

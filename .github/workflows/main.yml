name: RDP

on:
  workflow_dispatch:

jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 3600

    steps:
      - name: Configure Core RDP Settings
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          netsh advfirewall firewall delete rule name="RDP-Local"
          netsh advfirewall firewall add rule name="RDP-Local" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force

      - name: Create RDP User with Custom Credentials
        run: |
          $username = "${{ secrets.RDP_USERNAME }}"
          $password = "${{ secrets.RDP_PASSWORD }}"
          
          if ([string]::IsNullOrWhiteSpace($username) -or [string]::IsNullOrWhiteSpace($password)) {
              Write-Error "RDP_USERNAME and RDP_PASSWORD secrets must be set in repository settings"
              exit 1
          }
          
          secedit /export /cfg "$env:TEMP\secpol.cfg" | Out-Null
          (Get-Content "$env:TEMP\secpol.cfg") -replace "PasswordComplexity = 1", "PasswordComplexity = 0" | Set-Content "$env:TEMP\secpol_new.cfg"
          secedit /configure /db c:\windows\security\local.sdb /cfg "$env:TEMP\secpol_new.cfg" /areas SECURITYPOLICY | Out-Null
          Remove-Item "$env:TEMP\secpol.cfg", "$env:TEMP\secpol_new.cfg" -Force -ErrorAction SilentlyContinue
          
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          try {
              New-LocalUser -Name $username -Password $securePass -AccountNeverExpires -ErrorAction Stop
              Write-Host "User '$username' created successfully"
          } catch {
              Write-Error "Failed to create user. Error: $($_.Exception.Message)"
              exit 1
          }
          
          Add-LocalGroupMember -Group "Administrators" -Member $username
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member $username
          
          echo "RDP_USERNAME=$username" >> $env:GITHUB_ENV
          echo "RDP_PASSWORD=$password" >> $env:GITHUB_ENV
          
          if (-not (Get-LocalUser -Name $username)) {
              Write-Error "User creation verification failed"
              exit 1
          }
          
          Write-Host "RDP user '$username' configured and ready"

      - name: Install and Configure OpenSSH Client
        run: |
          $sshClient = Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH.Client*'
          if ($sshClient.State -ne "Installed") {
              Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
          }
          Write-Host "OpenSSH client ready"
      
      - name: Verify RDP Service
        run: |
          $testResult = Test-NetConnection -ComputerName 127.0.0.1 -Port 3389
          if (-not $testResult.TcpTestSucceeded) {
              Write-Error "RDP service not responding on localhost:3389"
              exit 1
          }
          Write-Host "RDP service verified and ready"

      - name: Run Tunnel Manager with Auto-Refresh
        run: |
          function Start-PinggyTunnel {
              $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              Write-Host "[$timestamp] Starting Pinggy tunnel..."
              
              # Kill any existing SSH processes
              Get-Process ssh -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 3
              
              # Verify SSH is available
              $sshPath = (Get-Command ssh -ErrorAction SilentlyContinue).Source
              if (-not $sshPath) {
                  Write-Error "SSH command not found in PATH"
                  exit 1
              }
              Write-Host "Using SSH from: $sshPath"
              
              # Test basic SSH connectivity to Pinggy
              Write-Host "Testing connection to free.pinggy.io on port 443..."
              $testConn = Test-NetConnection -ComputerName free.pinggy.io -Port 443 -WarningAction SilentlyContinue
              if (-not $testConn.TcpTestSucceeded) {
                  Write-Error "Cannot reach free.pinggy.io:443"
                  exit 1
              }
              Write-Host "Connection test successful!"
              
              # Prepare log files
              $logFile = "$env:TEMP\pinggy_stdout.log"
              $errorFile = "$env:TEMP\pinggy_stderr.log"
              
              # Remove old logs
              Remove-Item $logFile -Force -ErrorAction SilentlyContinue
              Remove-Item $errorFile -Force -ErrorAction SilentlyContinue
              
              Write-Host "Starting SSH tunnel process..."
              
              # Start SSH with explicit shell execution to capture output properly
              $sshArgs = @(
                  "-p", "443",
                  "-R0:127.0.0.1:3389",
                  "-o", "StrictHostKeyChecking=no",
                  "-o", "ServerAliveInterval=30",
                  "-o", "ExitOnForwardFailure=yes",
                  "-v",
                  "m9oKScbEcJh+tcp@free.pinggy.io"
              )
              
              $processInfo = New-Object System.Diagnostics.ProcessStartInfo
              $processInfo.FileName = "ssh"
              $processInfo.Arguments = $sshArgs -join " "
              $processInfo.RedirectStandardOutput = $true
              $processInfo.RedirectStandardError = $true
              $processInfo.UseShellExecute = $false
              $processInfo.CreateNoWindow = $true
              
              $process = New-Object System.Diagnostics.Process
              $process.StartInfo = $processInfo
              
              # Capture output in real-time
              $stdoutBuilder = New-Object System.Text.StringBuilder
              $stderrBuilder = New-Object System.Text.StringBuilder
              
              $stdoutEvent = Register-ObjectEvent -InputObject $process -EventName OutputDataReceived -Action {
                  if ($EventArgs.Data) {
                      [void]$Event.MessageData.AppendLine($EventArgs.Data)
                      Write-Host "[SSH-OUT] $($EventArgs.Data)"
                  }
              } -MessageData $stdoutBuilder
              
              $stderrEvent = Register-ObjectEvent -InputObject $process -EventName ErrorDataReceived -Action {
                  if ($EventArgs.Data) {
                      [void]$Event.MessageData.AppendLine($EventArgs.Data)
                      Write-Host "[SSH-ERR] $($EventArgs.Data)"
                  }
              } -MessageData $stderrBuilder
              
              $started = $process.Start()
              if (-not $started) {
                  Write-Error "Failed to start SSH process"
                  exit 1
              }
              
              $process.BeginOutputReadLine()
              $process.BeginErrorReadLine()
              
              Write-Host "SSH process started with PID: $($process.Id)"
              Write-Host "Waiting for Pinggy URL (this takes 15-30 seconds)..."
              
              # Wait and extract URL
              $pinggyUrl = "URL not captured yet"
              $maxWait = 60
              $elapsed = 0
              
              while ($elapsed -lt $maxWait) {
                  Start-Sleep -Seconds 2
                  $elapsed += 2
                  
                  # Check if process died
                  if ($process.HasExited) {
                      Write-Host "SSH process exited with code: $($process.ExitCode)"
                      $stdout = $stdoutBuilder.ToString()
                      $stderr = $stderrBuilder.ToString()
                      Write-Host "`nFinal STDOUT:`n$stdout"
                      Write-Host "`nFinal STDERR:`n$stderr"
                      Write-Error "SSH tunnel failed to establish"
                      exit 1
                  }
                  
                  # Try to extract URL from captured output
                  $combinedOutput = $stdoutBuilder.ToString() + $stderrBuilder.ToString()
                  
                  if ($combinedOutput -match "tcp://([^\s\n\r\)]+)") {
                      $pinggyUrl = $matches[1].Trim()
                      Write-Host "`nURL FOUND: $pinggyUrl"
                      break
                  }
                  
                  Write-Host "Waiting... ($elapsed/$maxWait seconds)"
              }
              
              # Cleanup event handlers
              Unregister-Event -SourceIdentifier $stdoutEvent.Name -ErrorAction SilentlyContinue
              Unregister-Event -SourceIdentifier $stderrEvent.Name -ErrorAction SilentlyContinue
              
              Write-Host "`n========================================" -ForegroundColor Cyan
              Write-Host "=== TUNNEL ESTABLISHED ===" -ForegroundColor Cyan
              Write-Host "========================================" -ForegroundColor Cyan
              Write-Host "URL: $pinggyUrl" -ForegroundColor Green
              Write-Host "PID: $($process.Id)" -ForegroundColor Yellow
              Write-Host "========================================`n" -ForegroundColor Cyan
              
              return @{
                  Process = $process
                  URL = $pinggyUrl
              }
          }
          
          while ($true) {
              $tunnelInfo = Start-PinggyTunnel
              $process = $tunnelInfo.Process
              $url = $tunnelInfo.URL
              
              Write-Host "`n========================================"
              Write-Host "=== RDP ACCESS VIA PINGGY TUNNEL ==="
              Write-Host "========================================"
              Write-Host "Connection URL: $url"
              Write-Host "Username: $env:RDP_USERNAME"
              Write-Host "Password: $env:RDP_PASSWORD"
              Write-Host ""
              Write-Host "Connect using your RDP client:"
              Write-Host "  - Use the URL above as host:port"
              Write-Host "  - Tunnel will refresh in 55 minutes"
              Write-Host "========================================"
              Write-Host ""
              
              $endTime = (Get-Date).AddMinutes(55)
              while ((Get-Date) -lt $endTime) {
                  $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                  $remaining = [math]::Round(($endTime - (Get-Date)).TotalMinutes, 1)
                  
                  if ($process.HasExited) {
                      Write-Host "[$timestamp] WARNING: Tunnel died unexpectedly! Restarting..." -ForegroundColor Red
                      break
                  }
                  
                  Write-Host "[$timestamp] Tunnel active - $remaining minutes until refresh"
                  Start-Sleep -Seconds 300
              }
              
              Write-Host "`nRefreshing tunnel with new URL..." -ForegroundColor Yellow
              if (-not $process.HasExited) {
                  $process.Kill()
              }
              $process.Dispose()
              Start-Sleep -Seconds 3
          }
